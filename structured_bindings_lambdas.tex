% ********************************* HEADERS ***********************************
\documentclass{article}
\usepackage[top=.75in, bottom=.75in, left=.50in,right=.50in]{geometry}
\usepackage{fancyhdr}
\usepackage{titling}
\pagestyle{fancy}
\lhead{Structured bindings with polymorphic lambas}
\rhead{\thepage}
\usepackage{color}
\usepackage{graphicx}
\usepackage{listings}
\lstset{
  language=C++,
  showstringspaces=false,
  basicstyle={\small\ttfamily},
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{dkgreen},
}
\usepackage[colorlinks,urlcolor={blue}]{hyperref}
%\setlength{\parskip}{1em}
\usepackage{parskip}
\usepackage{indentfirst}
\setlength{\droptitle}{-4em}
% \usepackage{concmath}
% \usepackage[T1]{fontenc}
% ********************************* HEADERS ***********************************

\begin{document}
\title{\textbf{Structured bindings with polymorphic lambas}}
\author{Aaryaman Sagar (rmn100@gmail.com)}
\date{August 14, 2017}
\maketitle

\section{Introduction}

This paper proposes usage of structured with polymorphic lambdas, adding them
to another place where \texttt{auto} can be used as a declarator

\begin{lstlisting}
auto map = std::map<int, int>{{1, 2}, {3, 4}};
std::for_each((map, [](auto [key, value]) {
    cout << key << " " << value << endl;
});
\end{lstlisting}

This would make for nice syntactic sugar to situations such as the above
without having to decompose the tuple-like object manually, similar to how
structured bindings are used in range based for loops

\begin{lstlisting}
auto map = std::map<int, int>{{1, 2}, {3, 4}};
for (auto [key, value] : map) {
    cout << key << " " << value << endl;
}
\end{lstlisting}


\section{Motivation}

\subsection{Simplicity and uniformity}
Structured binding initialization can be used almost anywhere \texttt{auto} is
used to initialize a variable (not considering \texttt{auto} deduced return
types), and allowing this to happen in polymorphic lambdas would make code
simpler, easier to read and generalize better

\begin{lstlisting}
std::find_if(range, [](const auto& [key, value]) {
    return examine(key, value);
});
\end{lstlisting}

\subsection{Programmer demand}
There is some programmer demand and uniform agreement on this feature

\begin{enumerate}
    \item \href{https://stackoverflow.com/questions/45541334}{Stack Overflow:
        Can the structured bindings syntax be used in polymorphic lambdas}
    \item \href{https://goo.gl/fRSwNg}{ISO C++ : Structured bindings and
        polymorphic lambdas}
\end{enumerate}

\subsection{Prevalence}
It is not uncommon to execute algorithms on containers that contain a value
type that is either a tuple or a tuple-like decomposable class.  And in such
cases code usually deteriorates to manually unpacking the instance of the
decomposable class for maximum reaadability, for example

\begin{lstlisting}
auto result = std::count_if(map, [](const auto& key_value_pair) {
    const auto& key = key_value_pair.first;
    const auto& value = key_value_pair.second;

    return examine(key, process_key(key), value);
});
\end{lstlisting}

The first two lines in the lambda are just noise and can nicely be replaced
with structured bindings in the function parameter

\begin{lstlisting}
auto result = std::count_if(map, [](const auto& [key, value]) {
    return examine(key, process_key(key), value);
});
\end{lstlisting}


\section{Impact on the standard}
The proposal describes a pure language extension which is a non-breaking
change - code that was previously ill-formed now would have well-defined
semantics.


\section{Impact on overloading and function resolution}
Lambdas do not natively support function overloading, however one can lay out
lambdas in a way that they are overloaded, for example

\begin{lstlisting}
template <typename... Types> struct Overload { using Types::operator()...; };
template <typename... Types> Overload(Types...) -> Overload<Types...>;

namespace {
    constexpr auto one = [](int) {};
    constexpr auto two = [](char) {};
} // namespace <anonymous>

constexpr auto overloaded = Overload{one, two};
\end{lstlisting}

And in such a situation the consequences of this proposal must be considered.
The easiest way to understand this proposal is to consider the rough syntactic
sugar that this provides.  A polymorphic lambda with a structured binding
declaration translates to a simple functor with a templated
\texttt{operator()} method with the structured binding "decomposition"
happening inside the function

\begin{lstlisting}
auto lambda = [](auto [key, value]) { ... };

/**
 * Expansion of the above lambda in C++14 form with respect to overloading
 */
struct ANONYMOUS_LAMBDA {
    template <typename Type>
    auto operator()(Type&& instance) {
        auto [key, value] = std::forward<Type>(instance);
        ...
    }
};
\end{lstlisting}

(Note that the above is just for illustration purposes.  It has some
differences with the way such a lambda would translate into real code - the
forwarded instance prevents elision because it is an xvalue)

Given the above expansion, a polymorphic lambda behaves identically to a
lambda with a \textt{auto} return type.  And nothing special happens when
overloading

\begin{lstlisting}
template <typename... Types> struct Overload { using Types::operator()...; };
template <typename... Types> Overload(Types...) -> Overload<Types...>;

namespace {
    constexpr auto one = [](int) {};
    constexpr auto two = [](auto [key, value]) {};
} // namespace <anonymous>

static auto overloaded = Overload{one, two};

int main() {
    auto integer = int{1};
    auto pair = std::make_pair(1, 2);
    auto error = double{1};

    // calls the lambda named "one"
    overloaded(integer);
    // calls the lamdba named "two"
    overloaded(pair);
    // error
    overloaded(error);
}
\end{lstlisting}


\section{Compiler Diagnostics}
The last case in the example above leads to a natural question - what happens
when a type is passed to a polymorphic lambda accepting a structured bindings
decomposable value in such a way that either the cardinality of the
decomposable value is not equal to the cardinality (if any) of the
decomposable part of the type.

Any compiler diagnostics provided are the same as that for regular structured
bindings initializations - with compiler intrinsic concepts if those are
included.


\section{Exceptions}
Exceptions during "unwrapping" (if, for example a member or free ADL defined
`get<>` throws) will propagate from the call site, just as with regular
polymorphic lambdas

\end{document}

