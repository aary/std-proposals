% ********************************* HEADERS ***********************************
\documentclass{article}
\usepackage[top=.75in, bottom=.75in, left=.50in,right=.50in]{geometry}
\usepackage{fancyhdr}
\usepackage{titling}
\pagestyle{fancy}
\lhead{Structured bindings with polymorphic lambas}
\rhead{\thepage}
\usepackage{color}
\usepackage{graphicx}
\usepackage{listings}
\lstset{
  language=C++,
  showstringspaces=false,
  basicstyle={\small\ttfamily},
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{dkgreen},
}
\usepackage[colorlinks,urlcolor={blue}]{hyperref}
%\setlength{\parskip}{1em}
\usepackage{parskip}
\usepackage{indentfirst}
\setlength{\droptitle}{-4em}
\usepackage{soul}
\usepackage{color}
\DeclareRobustCommand{\hlgreen}[1]{{\sethlcolor{green}\hl{#1}}}
\newcommand*\justify{%
  \fontdimen2\font=0.4em% interword space
  \fontdimen3\font=0.2em% interword stretch
  \fontdimen4\font=0.1em% interword shrink
  \fontdimen7\font=0.1em% extra space
  \hyphenchar\font=`\-% allowing hyphenation
}
% \usepackage{concmath}
% \usepackage[T1]{fontenc}
% ********************************* HEADERS ***********************************

\begin{document}
\title{\textbf{Structured bindings with polymorphic lambas}}
\author{Aaryaman Sagar (rmn100@gmail.com)}
\date{August 14, 2017}
\maketitle

\section{Introduction}

This paper proposes usage of structured bindings with polymorphic lambdas,
adding them to another place where \texttt{auto} can be used as a declarator

\begin{lstlisting}
auto map = std::map<int, int>{{1, 2}, {3, 4}};
std::for_each((map, [](auto [key, value]) {
    cout << key << " " << value << endl;
});
\end{lstlisting}

This would make for nice syntactic sugar to situations such as the above
without having to decompose the tuple-like object manually, similar to how
structured bindings are used in range based for loops

\begin{lstlisting}
auto map = std::map<int, int>{{1, 2}, {3, 4}};
for (auto [key, value] : map) {
    cout << key << " " << value << endl;
}
\end{lstlisting}


\section{Motivation}

\subsection{Simplicity and uniformity}
Structured binding initialization can be used almost anywhere \texttt{auto} is
used to initialize a variable (not considering \texttt{auto} deduced return
types), and allowing this to happen in polymorphic lambdas would make code
simpler, easier to read and generalize better

\begin{lstlisting}
std::find_if(range, [](const auto& [key, value]) {
    return examine(key, value);
});
\end{lstlisting}

\subsection{Programmer demand}
There is some programmer demand and uniform agreement on this feature

\begin{enumerate}
    \item \href{https://stackoverflow.com/questions/45541334}{Stack Overflow:
        Can the structured bindings syntax be used in polymorphic lambdas}
    \item \href{https://goo.gl/fRSwNg}{ISO C++ : Structured bindings and
        polymorphic lambdas}
\end{enumerate}

\subsection{Prevalence}
It is not uncommon to execute algorithms on containers that contain a value
type that is either a tuple or a tuple-like decomposable class.  And in such
cases code usually deteriorates to manually unpacking the instance of the
decomposable class for maximum reaadability, for example

\begin{lstlisting}
auto result = std::count_if(map, [](const auto& key_value_pair) {
    const auto& key = key_value_pair.first;
    const auto& value = key_value_pair.second;

    return examine(key, process_key(key), value);
});
\end{lstlisting}

The first two lines in the lambda are just noise and can nicely be replaced
with structured bindings in the function parameter

\begin{lstlisting}
auto result = std::count_if(map, [](const auto& [key, value]) {
    return examine(key, process_key(key), value);
});
\end{lstlisting}


\section{Impact on the standard}
The proposal describes a pure language extension which is a non-breaking
change - code that was previously ill-formed now would have well-defined
semantics.


\section{Interaction with concepts and traits}
\textbf{Definition (\texttt{x-decomposable})} If a type can be decomposed into
a structured binding expression with \texttt{x} bindings, then it is said to
be \texttt{x-decomposable} (reference \texttt{[dcl.struct.bind]} for the exact
requirements).  More specifically, if the following expression is well formed
for a type \texttt{T}
\begin{lstlisting}
auto&& [one, two, three, ... , x] = o;
\end{lstlisting}
Where \texttt{decltype(o)} is \texttt{T}, then the type \texttt{T} is said to
be \texttt{x-decomposable}

This can be made available to the compiler as both a concept and a trait.  The
presence of such a concept makes it easy to define templates in terms of a
type that is \texttt{x-decomposable}.  A trait allows for the same thing but
can be considered more versatile as it also fits well with existing code that
employs value driven template specialization mechanisms and other more
complicated specialization workflows.

It is possible to make a concept or SFINAE trait that enables us to check if a
type is decomposable into \texttt{x} bindings by inspecting it's interface.
In particular the presence of an ADL defined or member \texttt{get<>()}
function and the existence of specialized \texttt{std::tuple\_element<>} and
\texttt{std::tuple\_size<>} traits qualifies something to be
\texttt{x-decomposable}.  However, a type can be \texttt{x-decomposable} even
when these are not present (see \texttt{[dcl.struct.bind]}p4)

\texttt{[dcl.struct.bind]}p2 and \texttt{[dcl.struct.bind]}p3 define
decomposability that can be checked by the programmer at compile time
(described above) via a concept or SFINAE trait.  However
\texttt{[dcl.struct.bind]}p4 describes a method of unpacking that cannot be
enforced purely by the language constructs available as of C++17.  As such a
compiler intrinsic, say \texttt{\_\_is\_decomposable<T, x>} is required.
Given such an intrinsic, defining a trait and concept that check if a type is
\texttt{x-decomposable} on top of that is trivial.  The trait itself can be
used as a backend for the concept, leaving its implementation entirely in user
code without the help of compiler intrinsics.

The concept, say \texttt{std::decomposable<x>} accepts a non type template
parameter of type \texttt{std::size\_t} that determines the cardinality of the
structured bindings decomposition.  This concept holds if a type is
\texttt{x-decomposable} (and this will take into consideration the
requirements set forth by \texttt{[dcl.struct.bind]} paragraphs 2, 3 and 4.

The corresponding trait, say \texttt{std::is\_decomposable<T, x>} inherits
from either \texttt{std::true\_type} or \justify{\texttt{std::false\_type}}
based on whether the type \texttt{T} is \texttt{x-decomposable}.  The usual
variable template \texttt{std::is\_decomposable\_v<T, x>} should also be
defined.


\section{Impact on overloading and function resolution}
Lambdas do not natively support function overloading, however one can lay out
lambdas in a way that they are overloaded, for example

\begin{lstlisting}
template <typename... Types>
struct Overload : public Types... {
    using Types::operator()...;
};
template <typename... Types>
Overload(Types...) -> Overload<Types...>;

namespace {
    auto one = [](int) {};
    auto two = [](char) {};
    auto overloaded = Overload{one, two};
} // namespace <anonymous>
\end{lstlisting}

And in such a situation the consequences of this proposal must be considered.
The easiest way to understand this proposal is to consider the rough syntactic
sugar that this provides.  A polymorphic lambda with a structured binding
declaration translates to a simple functor with a templated
\texttt{operator()} method with the structured binding "decomposition"
happening inside the function

\begin{lstlisting}
auto lambda = [](const auto [key, value]) { ... };

/**
 * Expansion of the above lambda in C++17 form with respect to overloading
 */
struct ANONYMOUS_LAMBDA {
    template <std::decomposable<2> Type>
    auto operator()(const Type instance) const {
        auto& [key, value] = instance;
        ...
    }
};
\end{lstlisting}

Note that although this expansion has almost the same semantics as the actual
lambda.  The above is just for illustration purposes.  It has some
differences with the way such a lambda would translate into real code - for
example, returning a value from the structured bindings in the initialization
would not be a candidate for NRVO because of the explicit disallowance in
\texttt{[class.copy.elision]}, but here it might be.

Given the above expansion, a polymorphic lambda behaves identically to a
lambda with a \textt{auto} parameter type with the difference that these are
constrained to work only with parameters that are \texttt{x} decomposable.
And nothing special happens when overloading

\begin{lstlisting}
template <typename... Types>
struct Overload : public Types... {
    using Types::operator()...;
};
template <typename... Types>
Overload(Types...) -> Overload<Types...>;

namespace {
    auto one = [](int) {};
    auto two = [](auto [key, value]) {};
    auto overloaded = Overload{one, two};
} // namespace <anonymous>

int main() {
    auto integer = int{1};
    auto pair = std::make_pair(1, 2);
    auto error = double{1};

    // calls the lambda named "one"
    overloaded(integer);
    // calls the lamdba named "two"
    overloaded(pair);
    // error
    overloaded(error);
}
\end{lstlisting}

One key point to consider here is that the concept based constraints on such
lambdas allows for the following two orthogonal overloads to work nicely with
each other

\begin{lstlisting}
namespace {
    auto lambda_one = [](auto [one, two]) {};
    auto lambda_two = [](auto [one, two, three]) {};
    auto overloaded = Overload{lambda_one, lambda_two};
} // namespace <anonymous>

int main() {
    auto tup_one = std::make_tuple(1, 2);
    auto tup_two = std::make_tuple(1, 2, 2);
    overloaded(tup_one);
    overloaded(tup_two);

    return 0;
}
\end{lstlisting}

Since here either one lambda can be called or both, in no case can both
satisfy the requirements set forth by the compiler concept
\texttt{std::decomposable<x>}


\section{Conversions to function pointers}
A capture-less polymorphic lambda with structured binding parameters can also
be converted to a plain function pointer.  Just like a regular polyorphic
lambda

\begin{lstlisting}
auto f_ptr = static_cast<void (*) (std::tuple<int, int>)>([](auto [a, b]){});
\end{lstlisting}

So another conversion operator needs to be added to the expansion of the
polymorphic lambda with structured bindings above

\begin{lstlisting}
auto lambda = [](const auto [one, two]) { ... };

/**
 * Expansion of the above lambda in C++17 form with respect to overloading
 */
struct ANONYMOUS_LAMBDA {
    template <std::decomposable<2> Type>
    auto operator()(const Type instance) const {
        auto& [one, two] = instance;
        ...
    }

private:
    /**
     * Cannot use operator() because that will either cause moves or copies,
     * elision isn't guaranteed to happen to function parameters (even in
     * return values)
     */
    template <std::decomposable<2> Type>
    static auto invoke(const Type instance) {
        auto& [key, value] = instance;
        ...
    }

public:
    /**
     * Enforce the decomposable requirement on the argument of the function
     */
    template <typename Return, std::decomposable<2> Arg>
    operator Return(*)(Arg)() const {
        return &invoke;
    }
};
\end{lstlisting}

And like regular polymorphic lambdas, returning the address of the static
function invokes an instantiation of the function with the types used in the
conversion operator

\section{Exceptions}
Exceptions during "unwrapping" (if, for example a member or free ADL defined
\texttt{get<>} throws) will propagate from the call site, just as with regular
polymorphic lambdas


\section{Changes to the current C++17 standard}
\subsection{Section 8.1.5.1 (\texttt{[expr.prim.lambda.closure]}) paragraph 3}

For a generic lambda, the closure type has a public inline function call
operator member template (17.5.2) whose \texttt{\justify template-parameter-list}
consists of one invented type \texttt{template-parameter} for each occurrence
of \texttt{auto} in the lambda’s \texttt{parameter-declaration-clause}, in
order of appearance.  \hlgreen{For each occurrence of a structured binding with
cardinality \texttt{x}, the \texttt{template-parameter-list} consists of an
invented type \texttt{template-parameter} with the constraint that it has to
be decomposable into \texttt{x} structured bindings (see
\texttt{[dcl.struct.bind]}).  And as such the function template only
participates in overloading when all the structured bindings are appropriately
decomposable at the call site.} The invented type \texttt{template-parameter}
is a parameter pack if the corresponding \texttt{parameter-declaration}
declares a function parameter pack (11.3.5).  \hlgreen{A structured binding
\texttt{parameter-declaration} cannot be used to invent a parameter pack.} The
return type and function parameters of the function call operator template are
derived from the \texttt{lambda-expression}’s \texttt{trailing-return-type}
and \texttt{parameter-declaration-clause} by replacing each occurrence of auto
in the decl-specifiers of the \texttt{parameter-declaration-clause} with the
name of the corresponding invented \texttt{template-parameter}.


\subsection{Section 11.5 (\texttt{[dcl.struct.bind]})}

\hlgreen{5.  If the number of structured bindings introduced by a structured
binding declaration is \texttt{x}, then a type \texttt{T} is called
\texttt{x-decomposable} if the following is well formed}
\begin{lstlisting}
auto&& [one, two, three, ... , x] = o;
\end{lstlisting}

\hlgreen{where \texttt{T} is \texttt{decltype(o)}}

\subsection{Section 23.15.4.3 Type properties (\texttt{[meta.unary.prop]})}

\begin{lstlisting}
template <typename T, std::size_t X>
struct is_decomposable;
\end{lstlisting}

\hlgreen{\textbf{Condition} The type \texttt{T} has to be
\texttt{x-decomposable} (see \texttt{[expr.prim.lambda.closure]}p3)}

\end{document}
